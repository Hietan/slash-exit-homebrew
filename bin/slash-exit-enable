#!/bin/bash

# slash-exit-enable - Setup script for slash-exit command
# Adds shell function to enable /exit command

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
# BLUE='\033[0;34m'  # Unused, commented out
NC='\033[0m' # No Color

# Configuration
SCRIPT_NAME="slash-exit-enable"
# FUNCTION_NAME="slash-exit"  # Unused, commented out

# Utility functions
log_info() {
    echo -e "${GREEN}[INFO]${NC} $*"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $*"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $*"
}

# Detect current shell
detect_shell() {
    local shell_name
    shell_name=$(basename "$SHELL")
    
    case $shell_name in
        zsh)
            echo "zsh"
            ;;
        bash)
            echo "bash"
            ;;
        *)
            echo "unsupported"
            ;;
    esac
}

# Get config file path for shell
get_config_file() {
    local shell_type=$1
    case $shell_type in
        zsh)
            echo "$HOME/.zshrc"
            ;;
        bash)
            echo "$HOME/.bashrc"
            ;;
        *)
            echo ""
            ;;
    esac
}

# Check if slash-exit is already configured
check_existing_config() {
    local config_file=$1
    
    if [[ -f "$config_file" ]]; then
        grep -q "slash-exit command" "$config_file" 2>/dev/null
    else
        return 1
    fi
}

# Create backup of config file
create_backup() {
    local config_file=$1
    local timestamp
    timestamp=$(date +%Y%m%d_%H%M%S)
    local backup_file="${config_file}.backup.${timestamp}"
    
    if [[ -f "$config_file" ]]; then
        cp "$config_file" "$backup_file"
        log_info "Created backup: $backup_file"
        return 0
    else
        log_warn "Config file doesn't exist, creating new one"
        return 1
    fi
}

# Get slash-exit binary path
get_slash_exit_path() {
    local script_dir
    script_dir=$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)
    local slash_exit_path="$script_dir/slash-exit"
    
    # Check if running from Homebrew
    if command -v brew >/dev/null 2>&1; then
        local brew_prefix
        brew_prefix=$(brew --prefix)
        if [[ -x "$brew_prefix/bin/slash-exit" ]]; then
            echo "$brew_prefix/bin/slash-exit"
            return 0
        fi
    fi
    
    # Check if local version exists
    if [[ -x "$slash_exit_path" ]]; then
        echo "$slash_exit_path"
        return 0
    fi
    
    # Fallback to system PATH
    if command -v slash-exit >/dev/null 2>&1; then
        command -v slash-exit
        return 0
    fi
    
    echo ""
    return 1
}

# Generate shell function
generate_shell_function() {
    local slash_exit_path=$1
    
    cat <<EOF

# slash-exit command (installed via homebrew)
'/exit'() {
    "$slash_exit_path" "\$@"
}
EOF
}

# Add function to config file
add_to_config() {
    local config_file=$1
    local shell_function=$2
    
    # Ensure config file exists
    touch "$config_file"
    
    # Add function to end of file
    echo "$shell_function" >> "$config_file"
    
    log_info "Added /exit function to $config_file"
}

# User confirmation
confirm_installation() {
    local shell_type=$1
    local config_file=$2
    
    echo
    echo "This will add a '/exit' function to your shell configuration:"
    echo "  Shell: $shell_type"
    echo "  Config: $config_file"
    echo
    
    read -p "Continue? (Y/n): " -n 1 -r
    echo
    
    if [[ $REPLY =~ ^[Nn]$ ]]; then
        return 1
    fi
    
    return 0
}

# Main installation function
install_slash_exit() {
    log_info "Setting up slash-exit command..."
    
    # Detect shell
    local shell_type
    shell_type=$(detect_shell)
    
    if [[ "$shell_type" == "unsupported" ]]; then
        log_error "Unsupported shell: $SHELL"
        log_error "Currently supported: zsh, bash"
        exit 1
    fi
    
    log_info "Detected shell: $shell_type"
    
    # Get config file
    local config_file
    config_file=$(get_config_file "$shell_type")
    
    if [[ -z "$config_file" ]]; then
        log_error "Could not determine config file for $shell_type"
        exit 1
    fi
    
    # Check if already configured
    if check_existing_config "$config_file"; then
        log_warn "slash-exit appears to be already configured in $config_file"
        echo "If you want to reinstall, please remove the existing configuration first."
        exit 0
    fi
    
    # Get slash-exit binary path
    local slash_exit_path
    if ! slash_exit_path=$(get_slash_exit_path); then
        log_error "Could not find slash-exit binary"
        log_error "Please ensure slash-exit is installed"
        exit 1
    fi
    
    log_info "Found slash-exit at: $slash_exit_path"
    
    # Confirm installation
    if ! confirm_installation "$shell_type" "$config_file"; then
        log_info "Installation cancelled"
        exit 0
    fi
    
    # Create backup
    create_backup "$config_file"
    
    # Generate and add shell function
    local shell_function
    shell_function=$(generate_shell_function "$slash_exit_path")
    add_to_config "$config_file" "$shell_function"
    
    echo
    log_info "Installation complete!"
    log_info "Please restart your shell or run: source $config_file"
    log_info "Then try typing: /exit"
    
    echo
    echo "Designed for Claude Code users who accidentally type /exit ðŸ˜Š"
}

# Show help
show_help() {
    cat <<EOF
$SCRIPT_NAME - Setup script for slash-exit command

USAGE:
    $SCRIPT_NAME [OPTIONS]

OPTIONS:
    -h, --help      Show this help message

DESCRIPTION:
    This script adds a shell function to enable the /exit command.
    When you type /exit, it will run the slash-exit animation instead
    of trying to execute a non-existent command.

    Supports: zsh, bash
    Creates timestamped backups of your shell configuration files.

EXAMPLES:
    $SCRIPT_NAME        # Interactive installation
    $SCRIPT_NAME -h     # Show help

EOF
}

# Parse command line arguments
main() {
    case "${1:-}" in
        -h|--help)
            show_help
            exit 0
            ;;
        "")
            install_slash_exit
            ;;
        *)
            log_error "Unknown option: $1"
            show_help
            exit 1
            ;;
    esac
}

# Run main function
main "$@"